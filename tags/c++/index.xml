<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>C&#43;&#43; on komorebi</title>
        <link>https://HuaDong1120.github.io/tags/c&#43;&#43;/</link>
        <description>Recent content in C&#43;&#43; on komorebi</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>komorebi</copyright>
        <lastBuildDate>Sat, 03 Jan 2026 19:37:38 +0800</lastBuildDate><atom:link href="https://HuaDong1120.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>从裸指针到所有权：C&#43;&#43; 智能指针到底解决了什么</title>
        <link>https://HuaDong1120.github.io/p/%E4%BB%8E%E8%A3%B8%E6%8C%87%E9%92%88%E5%88%B0%E6%89%80%E6%9C%89%E6%9D%83c-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%B0%E5%BA%95%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88/</link>
        <pubDate>Sat, 03 Jan 2026 19:37:38 +0800</pubDate>
        
        <guid>https://HuaDong1120.github.io/p/%E4%BB%8E%E8%A3%B8%E6%8C%87%E9%92%88%E5%88%B0%E6%89%80%E6%9C%89%E6%9D%83c-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%B0%E5%BA%95%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88/</guid>
        <description>&lt;h1 id=&#34;从裸指针到所有权c-智能指针到底解决了什么&#34;&gt;从裸指针到所有权：C++ 智能指针到底解决了什么
&lt;/h1&gt;&lt;h3 id=&#34;一裸指针的三类典型灾难&#34;&gt;一，裸指针的三类典型灾难
&lt;/h3&gt;&lt;h4 id=&#34;1忘记delete泄露&#34;&gt;1，忘记delete（泄露)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;通俗理解：&lt;strong&gt;“借了房间，退房没交钥匙，但酒店一直以为你在住，持续计费。“&lt;/strong&gt;
你向系统申请了一块内存空间(new),用完后忘记归还(没有delete)。这块内存虽然你不再使用了，但是系统以为你还在用，所以不能分配给别人。&lt;/li&gt;
&lt;li&gt;后果：程序运行时间越长，占用的内存就越多，最后耗尽电脑内存，导致程序甚至系统崩溃。&lt;/li&gt;
&lt;li&gt;代码示例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;memoryLeak&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 申请了内存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 做了一些事情...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 函数结束了，但是忘记写 delete ptr;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 这块内存永远丢失了，直到程序结束
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;2重复delete双重释放double-free&#34;&gt;2，重复delete(双重释放/Double free)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;通俗理解：&lt;strong&gt;“退房之后，又跑去前台再退一次房。”&lt;/strong&gt;
你已经把这块内存归还给系统了，然后你又拿着同一个地址又去归还一次。&lt;/li&gt;
&lt;li&gt;后果：破坏了内存管理器的内部结构。第一次归还后，这块内存可能又被分配给别的变量了，你再强制回收，会导致程序立即崩溃（Crash),或者破坏其他正常数据。&lt;/li&gt;
&lt;li&gt;代码示例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;doubleFree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 第一次释放，正常
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ... 中间可能经过了复杂的逻辑 ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 第二次释放同一个地址 -&amp;gt; 灾难！程序崩溃
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;3早删悬垂使用已释放内存use-after-free&#34;&gt;3，早删/悬垂（使用已释放内存/Use-after-free)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;通俗理解：&lt;strong&gt;“房已经退了，新客人可能已经入住了，你还拿着备用钥匙进去睡觉。”&lt;/strong&gt;
你把内存释放了（delete），但是你手里的指针变量还在（此时它变成了“悬垂指针”/ Dangling Pointer）。如果你后续又通过这个指针去读取或写入数据，就是“Use-after-free”。&lt;/li&gt;
&lt;li&gt;后果：这是最危险的情况。
&lt;ul&gt;
&lt;li&gt;运气好：程序立刻崩溃。&lt;/li&gt;
&lt;li&gt;运气不好：程序没有崩溃，但你覆盖了那一块内存里此时存放的别人的数据（比如新客人的行李），导致数据错乱，产生极难排查的 Bug。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码示例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;useAfterFree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 内存已归还，ptr 变成了“悬垂指针”
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 错误！向已经不属于你的内存写入数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               &lt;span class=&#34;c1&#34;&gt;// 此时这块内存可能已经被系统分配给其他变量使用了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;二资源不只是内存文件句柄锁socket&#34;&gt;二，“资源”不只是内存：文件句柄、锁、socket
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;核心含义：在编程中（尤其是 C++），你需要手动管理的不仅仅是“内存条里的空间”，还有操作系统提供的其他有限资源。如果这些资源用完不还，后果可能比内存泄漏更严重。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;1文件句柄&#34;&gt;1，文件句柄
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;这是什么&lt;/strong&gt;：当你用代码打开一个文件时，操作系统会给你一个“号牌”（句柄/描述符），代表你有权操作这个文件。&lt;/li&gt;
&lt;li&gt;**如果不释放 ：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;比喻&lt;/strong&gt;：图书馆规定每个学生一次只能借 10 本书。你借了书看完不还，也不注销。虽然书架上还有书，但你的名额满了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后果&lt;/strong&gt;：&lt;strong&gt;“Too many open files”&lt;/strong&gt;。操作系统对每个进程能打开的文件数量是有限制的（比如默认 1024 个）。一旦泄露了文件句柄，程序就再也打不开任何新文件了，导致功能瘫痪。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-锁-locks--mutexes&#34;&gt;2， 锁 (Locks / Mutexes)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;这是什么&lt;/strong&gt;：在多线程编程中，为了防止数据打架，需要用“锁”来保护。线程 A 拿到锁，线程 B 就得在外面等，直到 A 释放锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果不释放 (忘记 unlock)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;比喻&lt;/strong&gt;：公共厕所只有一个坑位，进去必须锁门。如果你上完厕所直接跳窗跑了，门还锁着。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后果&lt;/strong&gt;：&lt;strong&gt;“死锁” (Deadlock)&lt;/strong&gt;。后面排队的所有人（其他线程）都会以为里面还有人，永远在门口死等。程序虽然没崩溃，但会“&lt;strong&gt;卡死&lt;/strong&gt;”不动了，这通常比崩溃更难处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3socket-网络套接字&#34;&gt;3，Socket (网络套接字)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;这是什么&lt;/strong&gt;：建立网络连接时（比如连接服务器或数据库），需要占用一个端口和相关的系统资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果不释放 (忘记 close)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;比喻&lt;/strong&gt;：你是电话接线员，接通了一个电话后，聊完了不挂机，占着线路。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后果&lt;/strong&gt;：&lt;strong&gt;“端口耗尽”&lt;/strong&gt;。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;客户端&lt;/strong&gt;：没法发起新的连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务器&lt;/strong&gt;：如果服务器处理完请求不关闭 Socket，很快就会把服务器的连接数占满，导致其他正常用户无法访问（类似遭受了 DoS 攻击）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三raii构造获取资源析构释放资源&#34;&gt;三，RAII：构造获取资源、析构释放资源
&lt;/h3&gt;&lt;h4 id=&#34;1核心思想&#34;&gt;1，核心思想
&lt;/h4&gt;&lt;p&gt;它的思想是：&lt;strong&gt;把资源的生命周期绑定到一个对象的生命周期上&lt;/strong&gt;。
可以去查看所有的现代Cpp工程或是开源项目，稍微有点规模的，都是有这个思想，创建一个对象时，构造函数自动被调用，出生即持有资源，当对象生命结束，超过作用域，Cpp的语言机制会保证自动调用析构函数，在这里我们把资源释放掉，析构释放资源。&lt;/p&gt;
&lt;h4 id=&#34;2为什么这样做&#34;&gt;2,为什么这样做？
&lt;/h4&gt;&lt;p&gt;想象一下上一节里的“锁”和“文件”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;没有 RAII（手动挡）&lt;/strong&gt;：&lt;br&gt;
你就像是一个去住酒店的人。你要自己去前台办入住（open），离开时必须自己记得去退房（close）。如果你突然有急事（程序抛出异常）直接跑了，或者单纯忘了退房，房间就永久被占用了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;有了 RAII（自动挡 / 房卡模式）&lt;/strong&gt;：&lt;br&gt;
现在酒店升级了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;构造&lt;/strong&gt;：你进房间插卡取电（对象创建，资源获取）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;析构&lt;/strong&gt;：你拔卡离开房间，灯光自动熄灭，房门自动上锁（对象销毁，资源自动释放）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重点&lt;/strong&gt;：不管你是正常走出去，还是被人抬出去（异常），只要卡（对象）离开了房间（作用域），断电（释放）是物理上必然发生的，&lt;strong&gt;你根本不需要靠脑子去记“要关灯”这件事&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3代码对比&#34;&gt;3，代码对比
&lt;/h4&gt;&lt;p&gt;过去模式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;oldWay&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;mtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 1. 手动上锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ... 执行任务 ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;something_wrong&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 哎呀！这里忘记写 unlock() 了！
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 直接返回，导致死锁（Deadlock），别人再也进不来了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;mtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 2. 手动解锁（如果没执行到这里就完蛋了）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;现代模式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;raiiWay&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 下面这行代码创建了一个对象 guard
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 构造时：自动帮你 mtx.lock()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock_guard&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;guard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ... 执行任务 ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;something_wrong&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 重点来了！只要离开这个函数，guard 变量就会销毁。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// guard 的析构函数会自动帮你调用 mtx.unlock()。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 哪怕抛出异常，资源也百分之百会释放。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 函数结束，guard 销毁，自动解锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;四raii构造获取资源析构释放资源&#34;&gt;四，RAII：构造获取资源、析构释放资源
&lt;/h3&gt;&lt;h4 id=&#34;1独占型stdunique_ptr&#34;&gt;1，独占型：std::unique_ptr
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;“只能我拥有它，其它人没有权限拥有，但是可以转移所有权“&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;唯一性&lt;/strong&gt;：同一时刻，只能有一个unique_ptr指向这块内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不能复制&lt;/strong&gt;：不能写ptr2=ptr1,底层已经移除拷贝构造。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以转移(move)&lt;/strong&gt;:虽然不能复制，但是可以将控制权进行转移。
什么时候用？&lt;/li&gt;
&lt;li&gt;这是默认首选，如果不知道用哪个，就先用这个，适用绝大多少场景，几乎没有额外开销&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2共享型stdshared_ptr&#34;&gt;2，共享型：std::shared_ptr
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;“只要还有一个人在用，这块内存就不能删。”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用计数（Reference Counting）&lt;/strong&gt;：这是它的核心魔法。每多一个人（指针）指向这块内存，计数器就 +1；每少一个人（指针销毁或重置），计数器就 -1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动销毁&lt;/strong&gt;：当计数器变成 &lt;strong&gt;0&lt;/strong&gt; 时（也就是最后一个人也用完了），内存才会真正被释放。
什么时候用？&lt;/li&gt;
&lt;li&gt;当一块资源需要在多个不同的地方被共同拥有时。比unqiue_ptr慢一点点，要维护一个计数器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4弱引用型&#34;&gt;4,弱引用型
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;“我只是静静地看着，不管它死活。”&lt;/li&gt;
&lt;li&gt;它是 shared_ptr 的小跟班。它指向 shared_ptr 管理的对象，但是&lt;strong&gt;不增加计数&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果你通过 weak_ptr 去看对象，如果对象还在，你就能用；如果对象已经销毁了（因为所有 shared_ptr 都没了），它会告诉你“对象不存在了”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为什么要发明它？（解决 shared_ptr 的致命死穴）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;循环引用（Circular Reference）&lt;/strong&gt;：想象一下，对象 A 里有个 shared_ptr 指向 B，对象 B 里也有个 shared_ptr 指向 A。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;后果&lt;/strong&gt;：A 等 B 释放，B 等 A 释放。双方的计数器永远是 1，永远不会归零。这就是&lt;strong&gt;内存泄漏&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解法&lt;/strong&gt;：把其中一方（比如 B 指向 A）改成 weak_ptr。打破闭环，A 就能正常销毁了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
