[{"content":"从裸指针到所有权：C++ 智能指针到底解决了什么 一，裸指针的三类典型灾难 1，忘记delete（泄露) 通俗理解：“借了房间，退房没交钥匙，但酒店一直以为你在住，持续计费。“ 你向系统申请了一块内存空间(new),用完后忘记归还(没有delete)。这块内存虽然你不再使用了，但是系统以为你还在用，所以不能分配给别人。 后果：程序运行时间越长，占用的内存就越多，最后耗尽电脑内存，导致程序甚至系统崩溃。 代码示例： 1 2 3 4 5 6 void memoryLeak() { int* ptr = new int(10); // 申请了内存 // 做了一些事情... return; // 函数结束了，但是忘记写 delete ptr; // 这块内存永远丢失了，直到程序结束 } 2，重复delete(双重释放/Double free) 通俗理解：“退房之后，又跑去前台再退一次房。” 你已经把这块内存归还给系统了，然后你又拿着同一个地址又去归还一次。 后果：破坏了内存管理器的内部结构。第一次归还后，这块内存可能又被分配给别的变量了，你再强制回收，会导致程序立即崩溃（Crash),或者破坏其他正常数据。 代码示例： 1 2 3 4 5 6 7 8 void doubleFree() { int* ptr = new int(10); delete ptr; // 第一次释放，正常 // ... 中间可能经过了复杂的逻辑 ... delete ptr; // 第二次释放同一个地址 -\u0026gt; 灾难！程序崩溃 } 3，早删/悬垂（使用已释放内存/Use-after-free) 通俗理解：“房已经退了，新客人可能已经入住了，你还拿着备用钥匙进去睡觉。” 你把内存释放了（delete），但是你手里的指针变量还在（此时它变成了“悬垂指针”/ Dangling Pointer）。如果你后续又通过这个指针去读取或写入数据，就是“Use-after-free”。 后果：这是最危险的情况。 运气好：程序立刻崩溃。 运气不好：程序没有崩溃，但你覆盖了那一块内存里此时存放的别人的数据（比如新客人的行李），导致数据错乱，产生极难排查的 Bug。 代码示例： 1 2 3 4 5 6 7 8 9 void useAfterFree() { int* ptr = new int(10); delete ptr; // 内存已归还，ptr 变成了“悬垂指针” // ... *ptr = 20; // 错误！向已经不属于你的内存写入数据 // 此时这块内存可能已经被系统分配给其他变量使用了 } 二，“资源”不只是内存：文件句柄、锁、socket 核心含义：在编程中（尤其是 C++），你需要手动管理的不仅仅是“内存条里的空间”，还有操作系统提供的其他有限资源。如果这些资源用完不还，后果可能比内存泄漏更严重。\n1，文件句柄 这是什么：当你用代码打开一个文件时，操作系统会给你一个“号牌”（句柄/描述符），代表你有权操作这个文件。 **如果不释放 ： 比喻：图书馆规定每个学生一次只能借 10 本书。你借了书看完不还，也不注销。虽然书架上还有书，但你的名额满了。 后果：“Too many open files”。操作系统对每个进程能打开的文件数量是有限制的（比如默认 1024 个）。一旦泄露了文件句柄，程序就再也打不开任何新文件了，导致功能瘫痪。 2， 锁 (Locks / Mutexes) 这是什么：在多线程编程中，为了防止数据打架，需要用“锁”来保护。线程 A 拿到锁，线程 B 就得在外面等，直到 A 释放锁。 如果不释放 (忘记 unlock)： 比喻：公共厕所只有一个坑位，进去必须锁门。如果你上完厕所直接跳窗跑了，门还锁着。 后果：“死锁” (Deadlock)。后面排队的所有人（其他线程）都会以为里面还有人，永远在门口死等。程序虽然没崩溃，但会“卡死”不动了，这通常比崩溃更难处理。 3，Socket (网络套接字) 这是什么：建立网络连接时（比如连接服务器或数据库），需要占用一个端口和相关的系统资源。 如果不释放 (忘记 close)： 比喻：你是电话接线员，接通了一个电话后，聊完了不挂机，占着线路。 后果：“端口耗尽”。 客户端：没法发起新的连接。 服务器：如果服务器处理完请求不关闭 Socket，很快就会把服务器的连接数占满，导致其他正常用户无法访问（类似遭受了 DoS 攻击）。 三，RAII：构造获取资源、析构释放资源 1，核心思想 它的思想是：把资源的生命周期绑定到一个对象的生命周期上。 可以去查看所有的现代Cpp工程或是开源项目，稍微有点规模的，都是有这个思想，创建一个对象时，构造函数自动被调用，出生即持有资源，当对象生命结束，超过作用域，Cpp的语言机制会保证自动调用析构函数，在这里我们把资源释放掉，析构释放资源。\n2,为什么这样做？ 想象一下上一节里的“锁”和“文件”。\n没有 RAII（手动挡）：\n你就像是一个去住酒店的人。你要自己去前台办入住（open），离开时必须自己记得去退房（close）。如果你突然有急事（程序抛出异常）直接跑了，或者单纯忘了退房，房间就永久被占用了。\n有了 RAII（自动挡 / 房卡模式）：\n现在酒店升级了。\n构造：你进房间插卡取电（对象创建，资源获取）。 析构：你拔卡离开房间，灯光自动熄灭，房门自动上锁（对象销毁，资源自动释放）。 重点：不管你是正常走出去，还是被人抬出去（异常），只要卡（对象）离开了房间（作用域），断电（释放）是物理上必然发生的，你根本不需要靠脑子去记“要关灯”这件事。 3，代码对比 过去模式：\n1 2 3 4 5 6 7 8 9 10 11 12 void oldWay() { std::mutex mtx; mtx.lock(); // 1. 手动上锁 // ... 执行任务 ... if (something_wrong) { // 哎呀！这里忘记写 unlock() 了！ return; // 直接返回，导致死锁（Deadlock），别人再也进不来了 } mtx.unlock(); // 2. 手动解锁（如果没执行到这里就完蛋了） } 现代模式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void raiiWay() { std::mutex mtx; // 下面这行代码创建了一个对象 guard // 构造时：自动帮你 mtx.lock() std::lock_guard\u0026lt;std::mutex\u0026gt; guard(mtx); // ... 执行任务 ... if (something_wrong) { return; // 重点来了！只要离开这个函数，guard 变量就会销毁。 // guard 的析构函数会自动帮你调用 mtx.unlock()。 // 哪怕抛出异常，资源也百分之百会释放。 } } // 函数结束，guard 销毁，自动解锁 四，RAII：构造获取资源、析构释放资源 1，独占型：std::unique_ptr “只能我拥有它，其它人没有权限拥有，但是可以转移所有权“ 唯一性：同一时刻，只能有一个unique_ptr指向这块内存。 不能复制：不能写ptr2=ptr1,底层已经移除拷贝构造。 可以转移(move):虽然不能复制，但是可以将控制权进行转移。 什么时候用？ 这是默认首选，如果不知道用哪个，就先用这个，适用绝大多少场景，几乎没有额外开销 2，共享型：std::shared_ptr “只要还有一个人在用，这块内存就不能删。” 引用计数（Reference Counting）：这是它的核心魔法。每多一个人（指针）指向这块内存，计数器就 +1；每少一个人（指针销毁或重置），计数器就 -1。 自动销毁：当计数器变成 0 时（也就是最后一个人也用完了），内存才会真正被释放。 什么时候用？ 当一块资源需要在多个不同的地方被共同拥有时。比unqiue_ptr慢一点点，要维护一个计数器 4,弱引用型 “我只是静静地看着，不管它死活。” 它是 shared_ptr 的小跟班。它指向 shared_ptr 管理的对象，但是不增加计数。 如果你通过 weak_ptr 去看对象，如果对象还在，你就能用；如果对象已经销毁了（因为所有 shared_ptr 都没了），它会告诉你“对象不存在了”。 为什么要发明它？（解决 shared_ptr 的致命死穴） 循环引用（Circular Reference）：想象一下，对象 A 里有个 shared_ptr 指向 B，对象 B 里也有个 shared_ptr 指向 A。\n后果：A 等 B 释放，B 等 A 释放。双方的计数器永远是 1，永远不会归零。这就是内存泄漏。\n解法：把其中一方（比如 B 指向 A）改成 weak_ptr。打破闭环，A 就能正常销毁了。\n","date":"2026-01-03T19:37:38+08:00","permalink":"https://HuaDong1120.github.io/p/%E4%BB%8E%E8%A3%B8%E6%8C%87%E9%92%88%E5%88%B0%E6%89%80%E6%9C%89%E6%9D%83c-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%B0%E5%BA%95%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88/","title":"从裸指针到所有权：C++ 智能指针到底解决了什么"}]